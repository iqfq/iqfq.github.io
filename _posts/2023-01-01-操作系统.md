---
title: 操作系统
date: 2023-01-01 09:00:00 +0000
categories: [计算机基础, 面经]
tags: [面经, 操作系统]
---

# 操作系统

## 什么是操作系统？

操作系统是管理计算机软硬件的一种应用程序。

### 操作系统负责将进程调度，那操作系统又是如何加载到内存的呢？

计算机分为内存和外存，外存主要指的是硬盘，而内存又可分为 ROM 和 RAM，ROM 只读不可写，RAM 也就是随机存储器，可读可写，ROM 在硬件生产时写入了一个自举程序，当计算机开机，自动运行，在硬盘查找操作系统并将其加载到内存中。

### 操作系统主要功能是什么？

进程管理、内存管理、文件管理、设备管理、提供用户接口

### 操作系统的主要作用？

帮助用户管理计算机资源、提供可视化的图形界面、为其他软件提供支持

### CPU 包括哪些部分？

CPU 主要包括四个部分，控制器、运算器、寄存器、时钟。

1. 控制器
   控制器负责将内存中的指令、数据等调入寄存器，根据指令调度计算机的各个部件。
2. 运算器
   运算器根据控制器的指令进行运算，返回结果给寄存器
3. 寄存器
   寄存器包括很多种，负责存储数值类型的数据的寄存器有：通用寄存器、累加寄存器、栈寄存器，负责存储程序、指令相关的寄存器有：程序计数器、指令寄存器，负责寻址相关的有：基址寄存器、变址寄存器，另外还有：标志寄存器
4. 时钟

### 操作系统内核

内核是操作系统最核心的部分，常驻内存，负责管理计算机的各种资源，比如控制 CPU，进程调度、内存资源分配、I/O 请求等

## 进程管理

### 什么是进程？

进程是程序运行的一个实例，是系统资源调度和分配的基本单位，进程实现了操作系统的并发。
在多道程序系统中，操作系统内存维护一个进程表，当有一个程序被运行，系统为其创建一个进程表项，也就是进程控制块 PCB，PCB 保存着该进程的唯一标识符 PID，程序计数器、堆栈指针、内存占用情况，根目录、工作目录等信息。

### 一个进程的执行过程是怎么样的？

写好的代码是存储的硬盘的静态文件，通过编译后会产生一个二进制的可执行文件一段 c++代码到 exe 的演变过程。当这个二进制文件被装载到内存，逐一执行其中的指令，那他就是一个执行中的程序，也就是进程。

### 进程执行过程的五个状态？

进程一般来说有五个状态，分别是，创建、就绪、运行、阻塞、结束。进程被创建时进入创建态，此时操作系统为其分配必要的资源，之后被进程调度程序调入等待队列，变为就绪状态，等待 cpu 资源。当获得 cpu 资源后，进入运行状态，当时间片完如果没有执行完，继续回到就绪状态，如果时间片内执行完毕则结束，而此时可能遇到 IO 请求等情况，进程会被挂起，进入阻塞状态，直到再次获得 cpu 资源后进入运行态继续执行。

### 并行和并发？

平时我们在使用电脑的时候，可以一边听音乐和一遍写代码，我们感觉起来这似乎是同时进行的，但是对于单核 cpu 系统来说，他们是交替进行的，所以并发指的就是，在同一个时间段内，多个程序同时执行，其实是交替进行。现在的电脑基本都是多核 cpu，所以听音乐和写代码完全可以交给两个 cpu 去执行，所以并行指的就是，多个程序在同一时刻同时执行。

### 进程调度有哪些算法

1. 先来先服务
2. 最短作业优先
3. 最短剩余时间优先
4. 时间片轮询
5. 优先级调度
6. 多级反馈调度

### 死锁

#### 死锁是什么？

在多道程序系统中，多个进程并发执行过程中，由于争夺资源而导致的互相等待的一种现象。

#### 产生死锁的原因有哪些？

死锁产生的原因包括系统资源的竞争、进程推进顺序不当、PV（信号量）使用不当三个主要原因。系统资源的竞争主要由于存在不可剥夺资源，进程推进顺序不当主要是考虑进程调度算法不合理，导致一个进程所需要的资源被另一个进程占用。而信号量使用不当可能导致进程之间出现互相等待的情况，从而发生死锁。

#### 死锁产生的条件是什么？

死锁产生的必要条件包括互斥、请求等待、不可剥夺、环路等待四个条件。

进程运行时会占有一定的资源，其他进程无法访问这些资源，这就是互斥条件。
进程需要的资源一般不会一次性得到，运行过程中还可能请求别的资源，但是请求的这部分资源可能被其他进程所占用，因此无法访问，所以进程会产生等待，这就是请求等待条件。
进程在结束前拥有的资源无法被其他进程所剥夺，只能由进程自己释放，这就是不可剥夺条件。
多个进程运行过程中，可能形成资源请求的循环等待链，链中的每一个进程占有的资源被上一个进程所请求。

#### 怎么解决死锁？

解决死锁的方法包括预防死锁（进程未执行前）、避免死锁（进程执行过程中）、检测和恢复死锁（死锁发生时）。

##### 如何预防死锁？

通过破坏死锁四个必要条件之一

1. 资源一次性分配，避免产生请求和保持
2. 当进程请求新的资源未成功时，释放已经占有的资源，避免不可剥夺条件
3. 资源有序分配，系统给不同类别的资源编号，进程按照顺序请求资源

##### 如何避免死锁？

1. 安全状态：没有发生死锁，或者进程突然请求最大资源数，通过某种调度次序能够使得所有进程执行完毕，那么该状态是安全的。如果一个状态是不安全的，则需要拒绝进入该状态。
2. 银行家算法

##### 如何检测和恢复死锁？

###### 如何检测？

进程-资源分配图没有产生环路则没有发生死锁
进程-资源分配图产生环路，如果资源类不存在多个资源，则发生死锁，否则，只能是产生死锁的必要不充分条件。在每个资源类中存在多个资源的情况时，如果资源-状态图可完全化简，则不一定产生死锁。

###### 如何恢复？

1. 资源剥夺
   剥夺陷入死锁的进程所占有的资源，但不撤销该进程，直到死锁解除。
2. 进程回退
   系统建立保存检查点，发生死锁时，让所有进程回退直到死锁解除
3. 进程撤销
   逐个撤销陷入死锁的进程，回收并重新分配资源，直到死锁解除。撤销所有陷入死锁的进程，解除死锁。
4. 重启系统

#### 知道哪些锁？

锁包括互斥锁、自旋锁、读写锁、乐观锁、悲观锁

1. 互斥锁
   互斥锁主要针对多线程情况，防止多个线程同时对一个公共资源进行读写导致异常。
2. 自旋锁
   自旋锁是实现多线程同步的一种锁，线程反复检查锁变量是否可用。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。由于线程在这一过程中保持执行，因此是一种忙等待。因此避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。
3. 读写锁
   读写锁是实现进程并发的一种同步机制，也称“共享-互斥锁”、多读者-单写者锁、多读者锁，用于解决读写问题。读操作可并发重入，写操作是互斥的。 读写锁通常用互斥锁、条件变量、信号量实现。
4. 乐观锁
   乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。
5. 悲观锁
   悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。

### 哲学家进餐问题

### 读写者问题

### 进程间通信的方式

进程间的通信方式包括管道、消息队列、共享内存、信号量、信号、Socket

1. 匿名管道
   采用半双工通信方式，数据单向流动，且只在父子关系进程使用
2. 高级管道
   将另一个程序当做子进程启动
3. 有名管道
   半双工通信，允许无亲缘关系的进程间通信

- 管道通信的缺点
  - 只能承载无格式字节流
  - 缓冲区大小受限

1. 消息队列
   存放在内核中的消息链表，由消息队列标识符标记
2. 信号量
   信号量用于对共享资源的访问控制，
3. 信号
   事件通信又叫信号通信，通知接收的进程某个事件已经发生
4. 共享内存
5. 套接字

### 线程

线程是进程的子任务，是 cpu 调度和分配的基本单位，线程实现了进程内部的并发

- 内核级线程
- 用户级线程

#### 线程同步的方式有哪些？

##### 互斥锁

##### 条件变量

##### 信号量

##### 读写锁

### 协程

是一种轻量级线程，协程的调度完全由用户控制

### 进程和线程的区别？

1. 归属：进程可拥有多个线程，一个线程只归属于一个进程
2. 资源：每个进程拥有各自独立的系统资源，而线程几乎不拥有系统资源，比如一些寄存器和栈，但是进程的所有线程可以共享该进程的所拥有的系统资源。
3. 开销：进程创建撤销开销大，线程创建、切换、撤销只涉及少量寄存器的内容，开销远小于进程。

### 线程和协程的区别

1. 一个线程可以拥有多个协程，一个进程也可单独拥有多个协程
2. 进程和线程都是同步机制，而协程是异步机制
3. 协程是组织好的代码流程，能保留上一次调用时的状态（下次调用时从 yield return 位置继续执行）
4. 线程是抢占式，而协程是非抢占式，因此用户需要自己释放使用权来切换其他协程（通过 yield return 归还运行权），所以同一时间其实只有一个协程在执行，相当于单线程的能力。
5. 线程是协程的资源，协程不会直接使用线程，而是通过执行器关联任意线程或线程池。

### 同步和异步

- 概念：
  - 同步：并发或并行的各个任务不是独立运行，任务之间存在一定的调用顺序，下一个任务需要等待上一个任务的结果才会执行。
  - 异步：并发或并行的各个任务是相互独立，各个任务之间互不影响。异步调用可以返回结果但是不需要等待结果返回，当结果返回时通过回调或其他方式执行其他任务。
- 理解：一家同步餐厅，第二位客人需要等待第一位客人点餐并用餐完之后才能够点餐，而异步餐厅为了提高营收，第一位客人单餐后，在一旁等待，前台告知厨房第一位客人的餐品后，继续接收第二位客人点餐

### 阻塞和非阻塞

## 内存管理

### 虚拟内存是什么？

虚拟内存是一种内存管理技术，通过页表将逻辑地址映射到物理地址，实现内存的统一管理，对于一个进程来说，它将拥有连续可用的内存空间，但实际上并不是。

### 为什么要有虚拟内存?

虚拟内存在程序运行所需要的内存和实际物理内存之间充当一个抽象。如果没有虚拟内存，当内存无法满足一个较大进程或者存在多个进程的运行时，程序便无法执行，加入虚拟内存，程序通过虚拟内存申请内存空间，当页表中不存在需要的物理地址时，产生缺页中断，需要从磁盘中取得缺页放入内存，当内存已满，虚拟内存会通过置换算法将磁盘中的页换出，相当于动态的管理内存。

### 虚拟内存实现方式？

1. 分段存储
   将内存空间分为大小不同的段
2. 分页存储
   在内存段内将空间分为大小相同的页，
3. 段页式存储

### 页表

> 虚拟内存和物理内存通过页表匹配，页表存在内存管理单元（MMU）

### 页面置换算法有哪些？

### 什么是缺页中断？

进程运行时需要访问内存，如果访问的页面不在内存中则需要从磁盘中调入，如果内存没有空闲空间时，则需要从内存从调出一页，再从磁盘中调入需要的页面。

1. 最佳置换算法（OPT）

最佳置换算法指的是将内存中未来最长一段时间内不使用的页面调出内存，但是由于人们无法预知这一结果，所以该算法无法实现。

2. 先进先出（FIFO）

```
<u>`先进先出算法指的是将当前最先调入的页面调出内存，也就是淘汰驻留内存最久的页面`</u>
```

3. 最近最久未使用（LRU）

最近最久未使用算法和先进先出相似，等同于动态的先进先出算法，区别在于先进先出算法不考虑

### 内存对齐

#### 什么是内存对齐？

变量按照定义顺序放入内存，但不是紧密排列，他们会按照各自类型的大小，保证首地址是类型大小的整数倍，

#### 为什么需要内存对齐？

1. 平台原因，有些硬件只能读取特定地址的数据，否则会出现异常。
2. 性能原因，没有内存对齐的数据，需要做两次内存访问，而内存对齐后，只需要进行一次。

### 内存碎片

内存碎片指的是一段空闲的内存空间，但却无法使用

1. 内部碎片
   由于内存管理的对齐机制，内存管理单元 MMU 每次只能申请固定大小的内存空间，但这块固定大小的内存空间不一定会被全部使用，这就会产生内部碎片。
2. 外部碎片
   由于内存分配顺序的原因，可能在两段已经分配的空间之间存在一段内存较小的内存，他不无法满足后续进程所需内存空间要求，因此编程不可用的状态。

### 怎么减少内存碎片？

1. 从程序角度的角度
   1. 减少动态内存空间的开辟，多复用空间
   2. 动态开辟的内存空间，及时释放
   3. 使用 union 减少内存占用
   4. 合理安排结构体和类的成员变量的位置，从内存对齐角度优化内存空间分配
   5. 手动维护内存分配机制
2. 从操作系统的角度
   1. 现代操作系统采用段页式存储结构分配内存

## 文件管理