---
title: 数据结构
date: 2023-01-03 09:00:00 +0000
categories: [计算机基础, 面经]
tags: [面经, 数据结构]
---

# 数据结构

## 顺序表

## 链表

### 单链表

### 双向链表

### 循环链表

## 哈希表表

哈希表也叫散列表，是一种键-值对映射的数据结构，利用空间换时间原理，使得查找能达到 O(1)时间复杂度。

### 哈希冲突

开放地址法（闭散列法）

开放地址法指的是所有数据都存放在一个哈希数组中，当发生哈希冲突时，选择最近可用的空单元存放。

双重散列法

双重散列法从字面意思可以知道使用了双层哈希结构，一般使用数组加链表形式，数组层发生哈希冲突时，将其添加到对应数组节点指向的链表末尾。

## 栈

- 两个栈构造队列

## 队列

## 树

- 树的高度
  - 指的是节点之间边的最大值，也就是从根节点出发，到达最外层叶子结点路径的最大值。
- 树的层数
  - 等于高度+1，层是节点所在，两个层之间就产生了一个高度

### 四序遍历

#### 先序遍历

#### 中序遍历

#### 后序遍历

#### 层次遍历

### 二叉树

- 数组存储

> - 下标从 0 开始
>
>   父节点：(i - 1) / 2
>
>   左子节点：2 \* i + 1
>
>   右子节点：2 \* i + 2
>
> - 下标从 1 开始
>
>   父节点为(i - 2) / 2
>
>   左子节点为 2 \* i
>
>   右子节点为 2 \* i + 1

### 完全二叉树

完全二叉树除了最外层，其余层满节点，并且最外层所有节点连续排列在左侧。

#### 堆

堆其实是一颗完全二叉树，如果对于每一个节点来说，父节点比子节点都大，则为大根堆。如果父节点比子节点都小，则为小根堆。

对于堆来说，只有当一层全部填满，才会开始填充下一层，所以对于一个 n 个节点的堆来说，高度为 log2n，层数为高度+1

### 满二叉树

满二叉树所有层都是满节点，满二叉树是特殊的完全二叉树

### 二叉搜索树

二叉搜索树不为空时满足一下条件，左子树所有节点比根节点小，右子树所有节点比根节点大，左右子树都是二叉搜索树。
查找
二叉查找树的查找从根节点遍历，比根节点小，往左子树递归，比根节点大，往右子树递归，等于根节点即查找成功，若为空则查找失败
插入
二叉查找树的插入和查找相似，待插入节点比根节点小，往左子树递归，比根节点大，往右子树递归，直到为空，则插入。
删除
二叉查找树的删除需要分三种情况，首先进行查找的步骤，查找到结点后：
如果该没有孩子节点，怎么将他删除，并且更新其父节点的指针。
如果存在一个节点，不管是存在左孩子还是右孩子，都会比待删除结点小，因此只需要将左孩子或者右孩子替换待删除结点。
如果存在左右孩子结点，有两种解决方式，使用左子树的最大结点替换待删除节点，或者使用右子树的最小节点替换待删除结点，这里说明一下正确性，根据二叉搜索树的性质，左子树所有结点会比根节点小，因此左子树的最大结点也会小于根节点，因为是最大结点，所以左子树其他结点也会比其更小，所以满足条件，右子树最小结点同理。用于替换的结点也需要做删除操作因此同样需要考虑三种情况，所以替换之后还需要递归删除替换的结点。
修改
二叉查找树的修改等同于先删除再插入

### 平衡二叉树（AVL）

### 红黑树

### 哈夫曼树

### B 树

#### B+树

#### B\*树

## 图

### 最小生成树

给出 n 个顶点，使用代价最小的 n-1 条边将所有顶点连接，也就是求最小连通图。

1. Prim 算法
   思想：维护两个集合，一个是已经在连通图中的顶点集合 left，另一个是为加入到连通图的顶点集合 right。首先 left 集合为空，right 集合包含所有顶点，选择一个起始点，加入 left，遍历他与其他顶点的构成的边，选择一条代价最小的边，将终点加入 left，加入 left 集合的顶点自动从 right 中移除，之后每次的操作，都是从 right 集合中选择一个到 left 集合代价最小的顶点加入 left，直到所有顶点都在连通图中。
   算法实现过程：每次从 right 集合中选一个到 left 集合代价最小的顶点怎么实现？考虑使用有限队列 priority_queue，同时使用 visited 数组记录顶点是否已经在连通图中。选择一个起始点，遍历他的所有边，此时其他所有顶点都不在连通图中，加入优先队列，按代价从小到大排序，接下来每次只需要取出队首顶点，然后遍历队首顶点到其他未加入连通图的顶点构成的边，依次加入优先队列，这样就可以保证每次都能得到一个到 left 集合代价最小的顶点。
